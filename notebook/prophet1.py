# -*- coding: utf-8 -*-
"""Prophet1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KaKPJsVtDq-48oCdjZMLfhlJz7Kqr7Ih
"""

# Imported necessary libraries

import numpy as np
import pandas as pd
import sys

# Connect to Google Drive (when running in Colab) to access project data files.

if('google.colab' in sys.modules):
    from google.colab import drive
    drive.mount('/content/drive', force_remount = True)
    DIR = '/content/drive/MyDrive/ProphetProject'
    DATA_DIR = DIR+'/Data/'
else:
    DATA_DIR = 'Data/'

# Load the sales dataset from the specified data directory into a pandas DataFrame.

file=DATA_DIR+'Data.csv'
data=pd.read_csv(file,header=0)
data

# Displays datatypes of each column

data.dtypes

# Checks the unique product values present in the dataset
product=data["product"].unique()
product

# Convert the sale_date column to datetime format

data['sale_date'] = pd.to_datetime(data['sale_date'])

# Re-checking the datatypes of columns

data.dtypes

"""The dataset is sorted by date and resampled to a monthly frequency to create a clean time-series representation suitable for forecasting."""

data = data.sort_values('sale_date')

monthly = (
    data
    .set_index('sale_date')
    .resample('ME')
    .agg({
        'product_unit_sales': 'sum',
        'discount_amount (Rs.)': 'sum',
        'mrp_amount (Rs.)': 'sum'
    })
)
data

"""# Reset the date index to a column and rename the date and target columns to 'ds' and 'y', which are required input column names for the Prophet model.

"""

monthly = monthly.reset_index()
monthly.rename(columns={'sale_date': 'ds', 'product_unit_sales': 'y'}, inplace=True)

"""# # Visualize the monthly sales trend over time to identify long-term patterns growth behavior, and potential structural changes in shirt sales."""

import matplotlib.pyplot as plt

plt.figure(figsize=(12,5))
plt.plot(monthly['ds'], monthly['y'])
plt.title('Yearly Shirt Sales Trend')
plt.xlabel('Year')
plt.ylabel('Units Sold')
plt.show()

"""# Visualize monthly seasonality by plotting the average sales for each calendar month to identify recurring demand patterns across the year.

"""

import calendar
import matplotlib.pyplot as plt

monthly['month'] = monthly['ds'].dt.month

seasonality = monthly.groupby('month')['y'].mean()

plt.figure(figsize=(10,4))
seasonality.plot(kind='bar')

plt.xticks(
    ticks=range(12),
    labels=[calendar.month_abbr[i] for i in range(1,13)],
    rotation=0
)

plt.xlabel('Month')
plt.ylabel('Average Sales')
plt.title('Average Monthly Sales (Seasonality)')
plt.show()

"""# Prepare the dataset for Prophet modeling by converting the date index into a  column and renaming the date, target, and regressor columns to the format required by the Prophet framework.

"""

monthly = monthly.reset_index()
monthly.rename(columns={
    'sale_date': 'ds',
    'product_unit_sales': 'y',
    'discount_amount (Rs.)': 'discount',
    'mrp_amount (Rs.)': 'mrp'
}, inplace=True)

"""# Import the Prophet forecasting model and the evaluation metric used to measure forecasting accuracy based on Mean Absolute Percentage Error (MAPE).

"""

from prophet import Prophet
from sklearn.metrics import mean_absolute_percentage_error

"""# Apply a logarithmic transformation to the target variable to stabilize variance and reduce the impact of extreme values, improving model robustness.

"""

monthly['y_log'] = np.log1p(monthly['y'])

"""# Define a rolling-window validation function that generates multiple train‚Äìvalidation splits, where each validation set spans 6 months of completely unseen data to evaluate forecasting performance over time.

"""

def rolling_validation(data, min_train=24, val_window=6):
    """
    Generates rolling train and 6-month validation sets
    """
    for start in range(min_train, len(data) - val_window):
        train = data.iloc[:start]
        val = data.iloc[start:start + val_window]
        yield train, val

"""# Define and configure the Prophet forecasting model by enabling yearly  seasonality, controlling trend flexibility, and incorporating external regressors such as discount and MRP to capture their impact on sales.

"""

def build_prophet_model():
    model = Prophet(
        yearly_seasonality=True,
        weekly_seasonality=False,
        daily_seasonality=False,
        changepoint_prior_scale=0.1
    )

    # External regressors
    model.add_regressor('discount')
    model.add_regressor('mrp')

    return model

"""# Perform rolling-window training and evaluation of the Prophet model by fitting the model on historical data, forecasting the next 6 months, and computing both Month-on-Month and cumulative 6-month MAPE to assess forecasting accuracy.

"""

results = []

for train, val in rolling_validation(monthly):

    model = build_prophet_model()

    model.fit(train[['ds', 'y_log', 'discount', 'mrp']]
              .rename(columns={'y_log': 'y'}))

    future = val[['ds', 'discount', 'mrp']]
    forecast = model.predict(future)

    # Convert predictions back to original scale
    y_pred = np.expm1(forecast['yhat'])
    y_true = val['y'].values

    # 1Ô∏è‚É£ Month-on-Month MAPE
    mom_mape = mean_absolute_percentage_error(y_true, y_pred)

    # 2Ô∏è‚É£ Overall 6-month MAPE (cumulative)
    overall_mape = mean_absolute_percentage_error(
        np.cumsum(y_true),
        np.cumsum(y_pred)
    )

    results.append({
        'MoM_MAPE_%': mom_mape * 100,
        'Overall_6M_MAPE_%': overall_mape * 100
    })

"""# Compile the forecasting evaluation metrics into a DataFrame and generate descriptive statistics to summarize the distribution of MAPE values across all rolling validation windows.


"""

results_df = pd.DataFrame(results)

results_df.describe()

"""# Calculate and display the proportion of rolling validation windows that meet the predefined accuracy threshold (‚â§ 15%) for both Month-on-Month MAPE and overall 6-month cumulative MAPE.

"""

print("MoM MAPE ‚â§ 15% pass rate:",
      (results_df['MoM_MAPE_%'] <= 15).mean())

print("Overall 6-Month MAPE ‚â§ 15% pass rate:",
      (results_df['Overall_6M_MAPE_%'] <= 15).mean())



def build_prophet_model():
    model = Prophet(
        yearly_seasonality=True,
        weekly_seasonality=False,
        daily_seasonality=False,
        n_changepoints=15,
        changepoint_prior_scale=0.3
    )

    # üîπ Custom quarterly seasonality
    model.add_seasonality(
        name='quarterly',
        period=91.25,
        fourier_order=5
    )

    # üîπ External regressors
    model.add_regressor('discount')
    model.add_regressor('mrp')

    return model

from sklearn.preprocessing import StandardScaler
import numpy as np

model_df = monthly.copy()

# Scale regressors
scaler = StandardScaler()
model_df[['discount', 'mrp']] = scaler.fit_transform(
    model_df[['discount', 'mrp']]
)

# Log transform target
model_df['y_log'] = np.log1p(model_df['y'])

def rolling_validation(data, min_train=24, val_window=6):
    for start in range(min_train, len(data) - val_window):
        train = data.iloc[:start]
        val = data.iloc[start:start + val_window]
        yield train, val

from sklearn.metrics import mean_absolute_percentage_error

results = []

for train, val in rolling_validation(model_df):

    model = build_prophet_model()

    model.fit(
        train[['ds', 'y_log', 'discount', 'mrp']]
        .rename(columns={'y_log': 'y'})
    )

    forecast = model.predict(
        val[['ds', 'discount', 'mrp']]
    )

    y_pred = np.expm1(forecast['yhat'])
    y_true = val['y'].values

    mom_mape = mean_absolute_percentage_error(y_true, y_pred)
    overall_mape = mean_absolute_percentage_error(
        np.cumsum(y_true),
        np.cumsum(y_pred)
    )

    results.append({
        'MoM_MAPE_%': mom_mape * 100,
        'Overall_6M_MAPE_%': overall_mape * 100
    })

results_df = pd.DataFrame(results)

print("MoM ‚â§ 15% pass rate:",
      (results_df['MoM_MAPE_%'] <= 15).mean())

print("Overall ‚â§ 15% pass rate:",
      (results_df['Overall_6M_MAPE_%'] <= 15).mean())

results_df.describe()

final_model = build_prophet_model()

final_model.fit(
    model_df[['ds', 'y_log', 'discount', 'mrp']]
    .rename(columns={'y_log': 'y'})
)

future = final_model.make_future_dataframe(periods=6, freq='M')

future['discount'] = model_df['discount'].iloc[-6:].mean()
future['mrp'] = model_df['mrp'].iloc[-6:].mean()

forecast = final_model.predict(future)
forecast['yhat_final'] = np.expm1(forecast['yhat'])

final_model.plot(forecast)

final_model.plot_components(forecast)

